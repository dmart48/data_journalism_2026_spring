---
title: "pre_lab_03.Rmd"
author: "Danny Martella"
date: "2026-01-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
```

## About this notebook

This notebook contains code and explanatory text that your should review and run as you read through two chapters on data cleaning from the course textbook, "Data Journalism with R and the Tidyverse". Answer questions and edit the document as directed.

Running this notebook will help you understand key data analysis methods and concepts that you will put into practice during this week's lab.

When you are finished running the code in this notebook, you will push changes to your course GitHub repo, and upload the link to ELMS as instructed.

## Data Cleaning, Part I

### Task 1: Load libraries and settings

**Task** Run the following code in the gray-colored codeblock below to load the tidyverse library and turn off scientific notation.

```{r}
# Remove scientific notation
options(scipen=999)
# Load the tidyverse   
library(tidyverse)
```

### Task 2: Load data

**Task** Load some [Maryland state government payments data](4) by running the following code. We'll use the guess_max() function as an argument to use the first 10 rows to set the data type. What does the first line of the red Warning message that prints out when you load the data say? What happens when you follow its instructions? Answer below. **Answer**
# The warning message says there are issues classifying data into columns because there are problems. When we call "problems()", we see that there are a lot of undesireable values that don't adhere to the expected zipcode value. 

```{r}
payments <- read_csv("data/State_of_Maryland_Payments_Data__FY2008_to_FY2024_20260122.csv.zip", guess_max=10)
```

### Task 3: Reload data

**Task** Run the following codeblock to reload the data, using every row to set the data types. Does it show any parsing errors when you run? Answer below **Answer**
#There are no erros in this code becuase it is looking at all of the data first. 
```{r}
payments <- read_csv("data/State_of_Maryland_Payments_Data__FY2008_to_FY2024_20260122.csv.zip", guess_max=392488)
```

### Task 4: Examine the data with glimpse

**Task** Run the following codeblock to glimpse the data. What data type is the "Vendor Name" field? What data type is the "Amount" field? What data type is the "Date" column? Answer below. **Answer**
#"Vendor Name" is a character type, "Amount" is a value, "Date" is a charcater.

```{r}
glimpse(payments)
```

Things that should be characters -- like agency name, vendor name -- are characters (chr). Things that should be numbers (dbl) -- like amount and fiscal year -- are numbers. We've seen before that sometimes dates aren't defined as date datatypes by R - we can fix that using `lubridate`.

### Task 5: Detect wrong spatial data

The second smell we can find in code is **wrong spatial data**. Spatial data means data that refers to some geography; in this dataset the only geographical element is the vendor's zip code. Zip codes should be, at a minimum, five characters long (although composed of numbers, zip codes aren't used as numbers).

We can check to see if any of the zip codes are less than five characters by using [a function called `str_length`](https://stringr.tidyverse.org/reference/str_length.html) inside a filter.

**Task** Run the following codeblock to group by the vendor's zip code and show any that are less than five characters in length. How many zip codes do not have five characters? What do you think explains those records? **Answer**

#560 vendors don't have the normal five digit format. This could happen because the a zero gets taken off. 

```{r}
payments |>
  group_by(`Vendor Zip`) |>
  filter(str_length(`Vendor Zip`) < 5) |> 
  summarise(
    count=n()
  ) |>
  arrange(desc(count))
```

What do state government payments have to do with churches? Let's find out:

**Task** Run the following codeblock to filter the payments data to show only payments to vendors with "CHURCH" in their name. How many payments were made to churches? What was the total amount paid to churches? **Answer**


```{r}
payments |>
  filter(str_detect(`Vendor Name`, "CHURCH")) |>
  group_by(`Vendor Name`) |>
  summarize(
    count = n(),
    total_amount = sum(Amount)
  ) |> 
  arrange(desc(total_amount))
```

Some interesting recipients in there.

### Task 6: Load Maryland grant and loan data

Let's now look at **gaps in data**. These often occur when you have a date or time element in your data, but there are other potential gaps, too. To illustrate those, we're going to introduce some Maryland state grant and loan data from 2009 forward. Let's load it and take a look:

**Task** Run the following codeblock to load Maryland state government grant and loan data

```{r}
md_grants_loans <- read_csv("data/State_of_Maryland_Grant_and_Loan_Data__FY2009_to_FY2024_20260122.csv")
```

Each row represents a recipient of state grant or loan, along with information about their location and the state agency that provided the money. When we talk about gaps, often they indicate the administrative rules. Here's an example: let's count the number of payments in each category (Grant or Loan) by year in this dataset.

### Task 7: Looking at categories

**Task** Run the following codeblock and describe below what each line is doing. Looking at the results, what jumps out at you as potentially problematic? **Answer**
#A lot of the data is inconsistent. Some years are missing data or have extra data. 

```{r}
md_grants_loans |> 
  group_by(`Fiscal Year`, Category) |> 
  summarize(count = n()) |> 
  arrange(`Fiscal Year`)
```

Any time you are going to focus on a column for analysis, you should check for unusual values. Are there any unusually large values or unusually small values? Are there any values that raise immediate questions about the data? Let's look at the smallest amounts in the grants and loan data.

### Task 8: Find outliers

**Task** Run the following code to arrange the grants & loan data so that the smallest amount is first. Describe what you see. **Answer**
# We see some strange outliers that are so low that they don't really make sense. Why would someone need a grant for $60. 

```{r}
md_grants_loans |> 
  arrange(Amount)
```

## Data Cleaning, Part II

### Task 1: Install janitor

**Task** Run the following codeblock to install the janitor package.

```{r}
install.packages('janitor')
```

### Task 2: Load janitor

**Task** Run the following code to load janitor.

```{r}
library(janitor)
```

Let's continue with our Maryland grants and loans data that we worked with in the previous chapter. There are a number of issues with this data set that might get in the way of asking questions and receiving accurate answers. They are:

-   The column names have spaces in them. This isn't a deal-breaker, as we used this dataframe previously. But it does require that you do some things differently when writing code, and ideally you don't want spaces in your column names.
-   Inconsistent capitalization across multiple columns. Sometimes the grantee is capitalized, and other times not. Portions of the grantor name are sometimes capitalized. This issue will ruin your ability to count and add things using those columns.
-   The zip field mixes five digit ZIP codes and nine digit ZIP codes, and some of the records include spaces. If we wanted to group and count the number of loans in a given ZIP code, this inconsistency would not let us do that correctly.
-   The category column is inconsistent and has some missing values.

Let's get cleaning. Our goal will be to build up one block of code that does all the necessary cleaning in order to answer this question: which organization with "CHURCH" in its name has gotten the most amount of grant/loan money from the state, and what's the zip code where it is located?

### Task 3: Use clean_names()

**Task** Run the following codeblock to use the `clean_names()` function from janitor to standardize column names. How does it change the headers? Answer below. **Answer**

#The headers are turned all lowercase and the spaces are replaced by underscores so that it is easier to identify them. 

```{r}
# cleaning function
cleaned_md_grants_loans <- md_grants_loans |>
  clean_names()

# display the cleaned dataset
cleaned_md_grants_loans
```

### Task 4: Use rename()

**Task** Run the following codeblock to use the clean_names() function from janitor to standardize column names and then use rename() to change the "grantor" column to "source". With `rename()` the new name comes first!

```{r}
# cleaning function
cleaned_md_grants_loans <- md_grants_loans |>
  clean_names() |> 
  rename(source = grantor)

# display the cleaned dataset
cleaned_md_grants_loans
```

Right now the `source`, `grantee` and `description` columns have inconsistent capitalization. We can fix that using a mutate statement and a function that changes the case of text called `str_to_upper()`. We'll use the same columns, overwriting what's in there since all we're doing is changing case.

### Task 5: Using str_to_upper() to standardize case

**Task** Run the following codeblock to use str_to_upper() to make the source, grantee and description columns upper-cased. Describe what each line is doing. **Answer**

#In this code block, we are are creating a new data set with lowercase and spaceless names. Then we are changing the "grantor" column title to "source." Then we are changeing source, grantee, and description columns so that the values are all uppercase lettered. 

```{r}
# cleaning function
cleaned_md_grants_loans <- md_grants_loans |>
  clean_names() |> 
  rename(source = grantor) |> 
  mutate(source = str_to_upper(source), grantee = str_to_upper(grantee), description = str_to_upper(description))

# display the cleaned dataset
cleaned_md_grants_loans
```

### Task 6: Check for duplicate rows

**Task** Run the following codeblock to check for duplicate rows using get_dupes(). How many duplicates are possible? **Answer**

#According to this code, there are 29 sets of duplicates in the dataset. 

```{r}
cleaned_md_grants_loans |>
  get_dupes()
```

### Task 7: Get rid of duplicate rows

**Task** Run the following codeblock to use distinct() to get rid of duplicate rows. How many rows does the new dataframe have? Answer below. **Answer**

#The new data set has 29 less observations.

```{r}
# cleaning function
cleaned_md_grants_loans <- md_grants_loans |>
  clean_names() |> 
  rename(source = grantor) |> 
  mutate(source = str_to_upper(source), grantee = str_to_upper(grantee), description = str_to_upper(description)) |> 
  distinct()

# display the cleaned dataset
cleaned_md_grants_loans
```

### Task 8: Clean up ZIP code

The rest of the problems with this data set all have to do with inconsistent format of values in a few of the columns. To fix these problems, we're going to make use of mutate() in concert with "string functions" -- special functions that allow us to clean up columns stored as character strings. The tidyverse package `stringr` has lots of useful string functions that you can look up!

Let's start by cleaning up the zip field. Remember, some of the rows had a five-digit ZIP code, while others had a nine-digit ZIP code, separated by a hyphen or not.

We're going to write code that tells R to make a new column for our zips, keeping the first five digits on the left, and get rid of anything after that by using `mutate()` in concert with `str_sub()`, from the `stringr` package.

**Task** Run the following codeblock to use str_sub() to convert the ZIP codes that have nine digits to five digits, creating a new column. Look at the difference in the result - what changed? **Answer**

#We now have a new column at the end of our data table called "zip5" which takes the first five digits of the zip column. 
```{r}
# cleaning function
cleaned_md_grants_loans <- md_grants_loans |>
  clean_names() |> 
  rename(source = grantor) |> 
  mutate(source = str_to_upper(source), grantee = str_to_upper(grantee), description = str_to_upper(description)) |> 
  distinct() |>
  mutate(zip5 = str_sub(zip_code, start=1L, end=5L))


# display the cleaned dataset
cleaned_md_grants_loans
```

### Task 9: Clean up zip5 field more with case_when()

**Task** Run the following codeblock to use case_when() to change clear non-zip codes into NA values.

```{r}
# cleaning function
cleaned_md_grants_loans <- md_grants_loans |>
  clean_names() |> 
  rename(source = grantor) |> 
  mutate(source = str_to_upper(source), grantee = str_to_upper(grantee), description = str_to_upper(description)) |> 
  distinct() |>
  mutate(zip5 = str_sub(zip_code, start=1L, end=5L)) |>
  mutate(zip5 = case_when(
    zip5 == "Vario" ~ NA,
    zip5 == "UB7 O" ~ NA,
    zip5 == "UB7 " ~ NA,
    .default = zip5
  ))

# display the cleaned dataset
cleaned_md_grants_loans
```

### Task 10: Answer our question!

**Task** Write and run code to answer our original question: which grantee with the word "CHURCH" in its name has gotten the most amount of grant/loan money from the state, and what is the zip code for it? Which of the top recipients is the most interesting to you? **Answer**

#To me, the Union Baptist Church School is interesting because this is a small church in one of the most underpriveliged parts of Baltimore (hence the grants I guess). When I looked them up, they seem to be a church with a preschool program that aims to help underpriveliged kids in the area, which seems like a noble cause. I think it would be an interesting story to go up there and see what they do and how they use the money. 

```{r}

cleaned_md_grants_loans |>
  filter(str_detect(grantee, "CHURCH")) |>
  group_by(grantee, zip5) |>
  summarize(
    count = n(),
    total_amount = sum(amount)
  ) |> 
  arrange(desc(total_amount))
```
